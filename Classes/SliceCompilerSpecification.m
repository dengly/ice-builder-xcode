// **********************************************************************
//
// Copyright (c) 2008-2016 ZeroC, Inc. All rights reserved.
//
// **********************************************************************

#import <SliceCompilerSpecification.h>
#import <Foundation/NSException.h>

@interface XCDependencyGraphCreationContext : NSObject
{
    PBXTargetBuildContext *_buildContext;
}
- (void)addNodeToClean:(id)node;
@end

@interface XCMacroExpansionScope : NSObject
{
    PBXTargetBuildContext *_buildContext;
    PBXTargetBuildContext *_cachedBuildContext;
    id _cachedSdk;
}
@property(readonly) PBXTargetBuildContext *buildContext;
-(id) dependencyGraphCreationContext;
-(id) evaluatedStringValueForMacroNamed:(id)arg1;
-(id) evaluatedStringListValueForMacroNamed:(id)arg1;
@end

@interface PBXTargetBuildContext(IceBuilder)
-(XCDependencyNode*) dependencyNodeForPath:(NSString*)path;
-(XCDependencyCommand*) createCommandWithRuleInfo:(NSArray*)info commandPath:(NSString*)path arguments:(NSArray*)args
                                          forNode:(XCDependencyNode*)node toolSpecification:(id)arg5
                          withMacroExpansionScope:(XCMacroExpansionScope*)arg6;
@end

@interface XCCompilerSpecification(IceBuilder)
-(NSArray*) commandLineForAutogeneratedOptionsWithMacroExpansionScope:(XCMacroExpansionScope*)scope;
@end

@interface SliceCompilerConfiguration : NSObject
{
@private
    NSString* translator;
    NSString* shlibpath;
    NSString* slicedir;
    BOOL cpp;
    BOOL sdk;
    NSString* error;
}

@property (readonly) NSString* translator;
@property (readonly) NSString* shlibpath;
@property (readonly) NSString* slicedir;
@property (readonly) NSString* icehome;
@property (readonly) BOOL cpp;
@property (readonly) BOOL sdk;
@property (readonly) NSArray* options;
@property (readonly) NSString* error;

-(id)initWithContext:(PBXTargetBuildContext*)context withScope:(XCMacroExpansionScope*)scope;

@end

@implementation SliceCompilerConfiguration

@synthesize translator;
@synthesize shlibpath;
@synthesize slicedir;
@synthesize icehome;
@synthesize cpp;
@synthesize sdk;
@synthesize options;
@synthesize error;

-(id)initWithContext:(PBXTargetBuildContext*)context withScope:(XCMacroExpansionScope*)scope
{
    if(!(self = [super init]))
    {
        return nil;
    }

    NSFileManager* fileManager = [NSFileManager defaultManager];
    [fileManager changeCurrentDirectoryPath:context.baseDirectoryPath];
    NSString* sliceIceHome = [scope evaluatedStringValueForMacroNamed:@"SLICE_ICE_HOME"];
    NSString* version = nil;
    NSString* canonicalName = nil;
    if(sliceIceHome.length > 0)
    {
        sdk = NO;
        BOOL dir = NO;
        if(![fileManager fileExistsAtPath:sliceIceHome isDirectory:&dir] || !dir)
        {
            error = [NSString stringWithFormat:@"Ice installation cannot be found: \"%@\"", sliceIceHome];
            return self;
        }

        slicedir = [sliceIceHome stringByAppendingPathComponent:@"share/slice"];
        if(![fileManager fileExistsAtPath:slicedir isDirectory:&dir] || !dir)
        {
            slicedir = [sliceIceHome stringByAppendingPathComponent:@"slice"];
            if(![fileManager fileExistsAtPath:slicedir isDirectory:&dir] || !dir)
            {
                error = [NSString stringWithFormat:@"Slice files cannot be found: \"%@\"", slicedir];
                return self;
            }
        }

        //
        // Is this a development tree, as opposed to an install? If so the bin and lib directories
        // are in cpp, not at the root.
        //
        NSString* homeCpp = [sliceIceHome stringByAppendingPathComponent:@"cpp"];
        if([fileManager fileExistsAtPath:homeCpp isDirectory:&dir] && dir)
        {
            sliceIceHome = homeCpp;
        }

        cpp = [[scope evaluatedStringValueForMacroNamed:@"SLICE_CPP_FLAG"] isEqualToString:@"YES"];

        NSString* exe = (cpp ? @"slice2cpp" : @"slice2objc");
        translator = [[sliceIceHome stringByAppendingPathComponent:@"bin"] stringByAppendingPathComponent:exe];

        NSDictionary* env = [[NSProcessInfo processInfo] environment];
        NSString* libdir = [sliceIceHome stringByAppendingPathComponent:@"lib"];
        shlibpath = [env objectForKey:@"DYLD_LIBRARY_PATH"];
        if(shlibpath)
        {
            shlibpath = [shlibpath stringByAppendingPathComponent:libdir];
        }
        else
        {
            shlibpath = libdir;
        }

        icehome = sliceIceHome;
    }
    else
    {
        NSString* sdksRaw = [scope evaluatedStringValueForMacroNamed:@"ADDITIONAL_SDKS"];
        NSArray* sdks = [sdksRaw componentsSeparatedByString:@" "];
        BOOL found = NO;
        for(__strong NSString* sdkDir in sdks)
        {
            NSString* sdkSettings = [sdkDir stringByAppendingPathComponent:@"SDKSettings.plist"];
            sdkDir = [sdkDir stringByDeletingLastPathComponent];
            if([sdkDir rangeOfString:@"Cpp"].location != NSNotFound)
            {
                translator = [sdkDir stringByAppendingPathComponent:@"bin/slice2cpp"];
                cpp = YES;
            }
            else if([sdkDir rangeOfString:@"ObjC"].location != NSNotFound)
            {
                translator = [sdkDir stringByAppendingPathComponent:@"bin/slice2objc"];
                cpp = NO;
            }
            else
            {
                cpp = [[scope evaluatedStringValueForMacroNamed:@"SLICE_CPP_FLAG"] isEqualToString:@"YES"];
                NSString* exe = (cpp ? @"slice2cpp" : @"slice2objc");
                translator = [[sdkDir stringByAppendingPathComponent:@"bin"] stringByAppendingPathComponent:exe];
            }

            if(![fileManager isExecutableFileAtPath:translator])
            {
                continue;
            }

            sdk = YES;
            found = YES;

            NSDictionary* settings = [NSDictionary dictionaryWithContentsOfFile:sdkSettings];
            if(settings)
            {
                canonicalName = [settings objectForKey:@"CanonicalName"];
                version = [settings objectForKey:@"Version"];
                if(!version)
                {
                    version = canonicalName;
                }
            }

            // The bin and slice directories exist at the root of the SDK.
            slicedir = [sdkDir stringByAppendingPathComponent:@"slice"];

            BOOL dir = NO;
            if(![fileManager fileExistsAtPath:slicedir isDirectory:&dir] || !dir)
            {
                error = [NSString stringWithFormat:@"Slice files cannot be found: \"%@\"", slicedir];
                return self;
            }
            break;
        }

        if(!found)
        {
            error = [NSString stringWithFormat:@"Ice SDK cannot be found: \"%@\"", sdksRaw];
            return self;
        }
    }

    NSString* libsuffix = @"";
    NSString* libstdcpp;
    if((version && [version rangeOfString:@"1.3"].location != NSNotFound) ||
       (icehome && [icehome rangeOfString:@"IceTouch-1.3"].location != NSNotFound))
    {
        //
        // If deployment target is 7.0 and 10.9 and libstdc++ isn't
        // set or if libc++ is set explicitly, link with libraries
        // suffixed with -libc++
        //
        if((([[scope evaluatedStringValueForMacroNamed:@"IPHONEOS_DEPLOYMENT_TARGET"] doubleValue] >= 7.0 ||
             [[scope evaluatedStringValueForMacroNamed:@"MACOSX_DEPLOYMENT_TARGET"] doubleValue] >= 10.9) &&
            ![[scope evaluatedStringValueForMacroNamed:@"CLANG_CXX_LIBRARY"] isEqualToString:@"libstdc++"]) ||
           [[scope evaluatedStringValueForMacroNamed:@"CLANG_CXX_LIBRARY"] isEqualToString:@"libc++"])
        {
            libsuffix = @"-libc++";
            libstdcpp = @"-lc++";
        }
        else
        {
            libstdcpp = @"-lstdc++";
        }
    }
    else
    {
        //
        // Make sure we are compiling with the libc++ library, we no longer support libstdc++
        //
        libstdcpp = @"-lc++";
        if([[scope evaluatedStringValueForMacroNamed:@"CLANG_CXX_LIBRARY"] isEqualToString:@"libstdc++"])
        {
            error = @"Ice doesn't support libstdc++";
            return self;
        }
    }

    //
    // Do we want to link service client libraries?
    //
    BOOL linkWithServices = [[scope evaluatedStringValueForMacroNamed:@"SLICE_LINK_WITH_SERVICES"] isEqualToString:@"YES"];

    //
    // Use C++11 mapping?
    //
    BOOL cpp11 = NO;
    cpp11 |= [[scope evaluatedStringListValueForMacroNamed:@"OTHER_CPLUSPLUSFFLAGS"]
        containsObject:@"-DICE_CPP11_MAPPING"];
    cpp11 |= [[scope evaluatedStringListValueForMacroNamed:@"GCC_PREPROCESSOR_DEFINITIONS"]
        containsObject:@"ICE_CPP11_MAPPING"];

    //
    // Format for link option
    //
    NSString* format;
    if((version && [version rangeOfString:@"1.3"].location != NSNotFound) ||
       (icehome && [icehome rangeOfString:@"IceTouch-1.3"].location != NSNotFound))
    {
        if(sdk)
        {
            format = [[@"-l%@" stringByAppendingString:cpp ? @"Cpp": @"ObjC"] stringByAppendingString:libsuffix];
        }
        else
        {
            format = [[@"-l%@" stringByAppendingString:cpp ? @"": @"ObjC"] stringByAppendingString:libsuffix];
        }
    }
    else
    {
        format = cpp ? (cpp11 ? @"-l%@++11" : @"-l%@") : @"-l%@ObjC";
    }

    //
    // Libraries
    NSMutableArray* libs = [NSMutableArray array];
    if(linkWithServices)
    {
        [libs addObjectsFromArray:[NSArray arrayWithObjects:@"Glacier2", @"IceStorm", @"IceGrid", nil]];
    }
    [libs addObject:@"Ice"];
    if([canonicalName rangeOfString:@"Ice SDK"].location != NSNotFound)
    {
        [libs addObject:@"IceSSL"];
    }
    if(!sdk && cpp)
    {
        if([fileManager fileExistsAtPath:[icehome stringByAppendingPathComponent:@"lib/libIceUtil.dylib"]])
        {
            [libs addObject:@"IceUtil"];
        }
    }

    NSMutableArray* opts = [NSMutableArray array];
    for(__strong NSString* lib in libs)
    {
        [opts addObject:[NSString stringWithFormat:format, lib]];
    }

    if([canonicalName rangeOfString:@"Ice SDK"].location != NSNotFound)
    {
        if(!cpp)
        {
            [opts addObject:@"-lIce"];
            [opts addObject:@"-lIceSSL"];
        }
        [opts addObject:@"-lIceLocatorDiscovery"];
        [opts addObject:@"-lIceDiscovery"];
    }

    [opts addObjectsFromArray:[NSArray arrayWithObjects:@"-liconv", @"-lbz2", nil]];

    if(!cpp)
    {
        [opts addObjectsFromArray:[NSArray arrayWithObjects:@"-ObjC", libstdcpp, nil]];
    }
    options = opts;
    return self;
}

-(NSString*)description
{
    return [NSString stringWithFormat:@"translator=%@ shlibpath=%@ slicedir=%@ cpp=%d",
            translator, shlibpath, slicedir, cpp];
}
@end


typedef struct Configuration Configuration;

@interface XMLSliceParserDelegate : NSObject<NSXMLParserDelegate>
{
@private

    NSMutableArray* depends;
}

@property(nonatomic, readonly) NSArray* depends;

-(void) parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI
    qualifiedName:(NSString *)qualifiedName attributes:(NSDictionary *)attributeDict;
@end

@implementation XMLSliceParserDelegate

@synthesize depends;

-(id) init
{
    if(![super init])
    {
        return nil;
    }
    depends = [[NSMutableArray alloc] init];
    return self;
}

-(void) parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI
    qualifiedName:(NSString *)qualifiedName attributes:(NSDictionary *)attributeDict
{
    if([elementName isEqualToString:@"dependsOn"])
    {
        NSString* name = [attributeDict objectForKey:@"name"];
        if(name != 0)
        {
            [depends addObject:name];
        }
    }
}

@end

@implementation SliceCompilerSpecification

-(NSArray*)dependenciesForSliceFile:(NSString*)path command:(XCDependencyCommand*)cmd
{
    NSTask *dependTask = [[NSTask alloc] init];
    NSMutableArray *args = [NSMutableArray array];

    [dependTask setLaunchPath:[cmd commandPath]];
    [dependTask setEnvironment:[cmd environment]];
    [dependTask setCurrentDirectoryPath:[cmd workingDirectoryPath]];

    NSPipe* newPipe = [NSPipe pipe];
    NSFileHandle* readHandle = [newPipe fileHandleForReading];
    NSData* inData = nil;

    [dependTask setStandardOutput:newPipe];

    [args addObjectsFromArray:[cmd arguments]];

    // Use old style dependency parsing?
    BOOL cpp = [[cmd commandPath] rangeOfString:@"slice2cpp"].location != NSNotFound;
    if(cpp)
    {
        [args addObject:@"--depend"];
    }
    else
    {
        [args addObject:@"--depend-xml"];
    }

    //
    // Always add --ice when parsing dependencies, this avoid
    // errors when try to parse dependencies for Ice Slice files.
    //
    BOOL found = NO;
    NSString* item;
    for(item in args)
    {
        if([item rangeOfString:@"--ice"].location != NSNotFound)
        {
            found = YES;
            break;
        }
    }

    if(!found)
    {
        [args addObject:@"--ice"];
    }

    [args addObject:path];

    //NSLog(@"args: %@", args);

    [dependTask setArguments:args];

    @try
    {
        [dependTask launch];
    }
    @catch(NSException* ex)
    {
        NSLog(@"translator not accessible");
        return [NSArray array];
    }

    NSMutableData* output = [[NSMutableData alloc] init];
    while((inData = [readHandle availableData]) && [inData length])
    {
        [output appendData:inData];
    }

    // Don't use NSTask waitUntilExit, this is for some reasons
    // causing crashes with Xcode.
    int wait = 500; // Wait 5 seconds.
    while([dependTask isRunning] && wait > 0)
    {
        [NSThread sleepForTimeInterval:0.01];
        --wait;
    }

    if([dependTask terminationStatus] != 0)
    {
        NSLog(@"translator exited with non-zero status %d", [dependTask terminationStatus]);
        return [NSArray array];
    }

    if(cpp)
    {
        NSMutableArray* dep = [NSMutableArray array];
        NSString* soutput = [[NSString alloc]initWithData:output encoding:NSUTF8StringEncoding];
        // Parse C++ style dependencies.
        NSArray* lines = [soutput componentsSeparatedByString:@"\n"];
        // Ignore the first two lines.
        if(lines.count > 2)
        {
            NSEnumerator *e = [lines objectEnumerator];
            [e nextObject]; // Foo.cpp
            [e nextObject]; // Foo.ice
            // The remaning lines are the slice dependencies themselves.
            NSString* line;
            while((line = [e nextObject]))
            {
                // Strip the trailing \ if any.
                if([line characterAtIndex:line.length-1] == '\\')
                {
                    line = [line substringToIndex:line.length-1];
                }
                // Strip leading and trailing whitespace
                line = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                // Don't add empty dependencies.
                if(line.length > 0)
                {
                    [dep addObject:line];
                }
            }
        }
        return dep;
    }
    else
    {
        // Parse XML style dependencies.
        XMLSliceParserDelegate* del = [[XMLSliceParserDelegate alloc] init];
        NSXMLParser* parser = [[NSXMLParser alloc] initWithData:output];
        [parser setDelegate:del];
        BOOL success = [parser parse];
        if(!success)
        {
            NSLog(@"XML parse of dependencies failed\n%@", output);
            return [NSArray array];
        }
        return [del depends];
    }
}

- (id)processDependencyInfoFileIfNecessaryForCommand:(id)cmd commandInvocationSucceeded:(BOOL)r;
{
    return ^ {
        NSMutableArray* dependencies = [NSMutableArray array];
        for(XCDependencyNode* node in [cmd inputNodes])
        {
            NSEnumerator *e = [[self dependenciesForSliceFile:[node path] command:cmd] objectEnumerator];
            NSString *filename;
            PBXTargetBuildContext* context = [cmd buildContext];
            while((filename = [e nextObject]))
            {
                XCDependencyNode *node = [context dependencyNodeForPath:[context absolutePathForPath:filename]];
                [node setDontCareIfExists:YES];
                [dependencies addObject:node];
            }
        }
        [cmd setDiscoveredInputNodes:dependencies];
    };
}

-(NSArray*) computeDependenciesForFilePath:(NSString*)input
                                    ofType:(PBXFileType*)type
                           outputDirectory:(NSString*)outputDir
                   withMacroExpansionScope:(XCMacroExpansionScope*)scope
{
    return [self computeDependenciesForFilePath:input
                                         ofType:type
                                outputDirectory:outputDir
                           inTargetBuildContext:scope.buildContext
                        withMacroExpansionScope:scope];
}

-(NSArray*) computeDependenciesForFilePath:(NSString*)input
                                    ofType:(PBXFileType*)type
                           outputDirectory:(NSString*)outputDir
                      inTargetBuildContext:(PBXTargetBuildContext*)context
                   withMacroExpansionScope:(XCMacroExpansionScope*)scope
{
    // compute input path (for variable substitution)
    input = [context absolutePathForPath:input];

    SliceCompilerConfiguration* conf = [[SliceCompilerConfiguration alloc] initWithContext:context withScope:scope];
    if(conf.error)
    {
        [context addDependencyAnalysisErrorMessageFormat:@"%@", conf.error];
        return [NSArray array];
    }

    // The output file goes in the derived files dir.
    NSString* generatedOutputDir = [scope evaluatedStringValueForMacroNamed:@"SLICE_OUTPUT_DIR"];

    NSString* outputBase = [generatedOutputDir stringByAppendingPathComponent:[[input lastPathComponent]
                                                                               stringByDeletingPathExtension]];
    NSString* sourceExtension = (conf.cpp) ? @"cpp" : @"m";
    NSString* sourceOutput = [outputBase stringByAppendingPathExtension:sourceExtension];
    NSString* headerOutput = [outputBase stringByAppendingPathExtension:@"h"];

    // create dependency nodes
    XCDependencyNode* outputSourceNode;
    XCDependencyNode* outputHeaderNode;
    XCDependencyNode* inputNode = [context dependencyNodeForPath:input];

    outputSourceNode = [context dependencyNodeForPath:sourceOutput];
    outputHeaderNode = [context dependencyNodeForPath:headerOutput];

    [[scope dependencyGraphCreationContext] addNodeToClean:outputSourceNode];
    [[scope dependencyGraphCreationContext] addNodeToClean:outputHeaderNode];

    // Create slice2objc command
    XCDependencyCommand* dep = [context createCommandWithRuleInfo:
        [NSArray arrayWithObjects:(conf.cpp ? @"slice2cpp" : @"slice2objc"), [context naturalPathForPath:input], nil]
                                     commandPath:conf.translator
                                       arguments:nil
                                         forNode:outputHeaderNode
                               toolSpecification:self
                         withMacroExpansionScope:scope];

    [dep addArgumentsFromArray:[self commandLineForAutogeneratedOptionsWithMacroExpansionScope:scope]];
    [dep addInputNode:inputNode];
    [dep addOutputNode:outputSourceNode];
    [dep addArgumentsFromArray:[scope evaluatedStringListValueForMacroNamed:@"build_file_compiler_flags"]];
    [dep addArgument:[NSString stringWithFormat:@"-I%@", conf.slicedir]];
    [dep addArgument:input];
    [dep setPhaseNumber:3]; // This is the phase that the yacc plugin uses.
    if(conf.shlibpath)
    {
        [dep addEnvironmentValue:conf.shlibpath forKey:@"DYLD_LIBRARY_PATH"];
    }

    // Add the source & headder output to the generated source files.
    [context addPath:sourceOutput toFilePathListWithIdentifier:@"GeneratedSourceFiles"];
    [context addPath:headerOutput toFilePathListWithIdentifier:@"GeneratedSourceFiles"];

    //
    // Add linker options (unless this is a static library project).
    //
    if(![[scope evaluatedStringValueForMacroNamed:@"MACH_O_TYPE"] isEqualToString:@"staticlib"])
    {
        [context addCompilerRequestedLinkerParameters:
                   [NSDictionary dictionaryWithObject:conf.options forKey:@"AdditionalCommandLineArguments"]];
    }

    return [NSArray arrayWithObjects:outputSourceNode, outputHeaderNode, nil];
}

@end
